require "poet/version"
require "thor"
require "fileutils"
require "digest/md5"

module Poet

  class AlreadyBootstrapped < StandardError; end
  class EmptyEditorVar < StandardError; end
  class HandCraftedConfigFound < StandardError; end
  class NotBootstrapped < StandardError; end

  class Runtime

    MAGIC_LINE = "# Generated by #{File.basename(__FILE__, '.rb')}"

    def initialize(options = {})
      @dir = options.delete(:dir)
      @force_include = options.delete(:force_include)
      @output = options.delete(:output)
    end

    def bootstrap(file)
      raise Poet::AlreadyBootstrapped if source_dir_exists?

      FileUtils.mkdir_p(@dir)
      FileUtils.mv(file, @dir) if File.file?(file)
    end

    def create(files_to_include = nil, &block)
      raise Poet::NotBootstrapped unless source_dir_exists?
      raise Poet::HandCraftedConfigFound if hand_crafted_config?
      puts "Found generated ssh_config under #{@output}. Overwriting..." if config_exists?

      # build content from list of files
      entries = files(files_to_include).sort.map do |file|
        yield(file.gsub(/^\.\//, '')) if block_given?
        ["\n# Located in #{file}", File.read(file)]
      end.flatten

      write_to_ssh_config(entries)
    end

    def edit(file)
      raise Poet::EmptyEditorVar if ENV['EDITOR'].to_s.empty?

      filepath = File.join(@dir, file)
      checksum_before = Digest::MD5.file(filepath) rescue '0'*16
      system("#{ENV['EDITOR']} #{filepath}")
      needs_update = File.exists?(filepath) && checksum_before != Digest::MD5.file(filepath)
      create([file]) if needs_update
    end

    def ls(show_tree: false)
      if show_tree
        print_tree(@dir)
      else
        files = Dir["#{@dir}/**/*"].sort.reject { |file| File.directory?(file) }
        puts files.map{|filename| filename[@dir.size+1..-1]}.join("\n")
      end
    end

    private

    def source_dir_exists?
      File.directory?(@dir)
    end

    def hand_crafted_config?
      config_exists? && !has_magic_line?
    end

    def config_exists?
      File.exists?(@output)
    end

    def has_magic_line?
      File.new(@output).gets == "#{MAGIC_LINE}\n"
    end

    def print_tree(dir = ".", nesting = 0)
      Dir.entries(dir).sort.each do |entry|
        next if entry =~ /^\.{1,2}/   # Ignore ".", "..", or hidden files
        puts "|   " * nesting + "|-- #{entry}"
        if File.stat(d = "#{dir}#{File::SEPARATOR}#{entry}").directory?
          print_tree(d, nesting + 1)
        end
      end
    end

    def files(files_to_include = nil)
      whitelist = files_to_include || @force_include.split(',').map{|file| "#{file}.disabled"}
      files = Dir["#{@dir}/**/*"].reject do |file|
        File.directory?(file) || \
          file =~ /\.disabled$/ && !whitelist.include?(File.basename(file))
      end

      files -= [@output]
    end

    def write_to_ssh_config(entries = [])
      File.open(@output, 'w', 0600) do |ssh_config|
        ssh_config.puts(MAGIC_LINE)
        ssh_config.puts("# DO NOT EDIT THIS FILE")
        ssh_config.puts("# Create or modify files under #{@dir} instead")
        ssh_config.puts(entries.join("\n"))
      end
    end
  end

end

class PoetCLI < Thor

  default_task :create
  class_option :dir,
      desc: 'Use specified directory to collect conf files',
      default: ENV['POET_GLOBDIR'] || File.expand_path('~/.ssh/config.d')
  class_option :output,
      desc: 'Generate output in specified file',
      aliases: '-o',
      default: ENV['POET_OUTPUT'] || File.expand_path('~/.ssh/config')
  class_option :with,
      desc: 'Include an otherwise disabled config file',
      aliases: '-w',
      default: ""
  class_option :verbose,
      desc: 'Be verbose',
      aliases: '-v',
      type: :boolean

  desc "bootstrap [FILE]",
      "Move ~/.ssh/config (or whatever you specified) to ~/.ssh/config.d/ to help you get started"
  def bootstrap(file=nil)
    Poet::Runtime.new(dir: options[:dir]).bootstrap(File.expand_path(file || options[:output]))
    create
  rescue Poet::AlreadyBootstrapped
    $stderr.puts "You're already good to go."
    Process.exit!(3)
  end

  desc "completeme", "Install completion for Bash into ~/.bash_completion.d/"
  def completeme
    completion_dir = File.expand_path("~/.bash_completion.d/")
    FileUtils.mkdir_p(completion_dir)
    say "Copying completion file to #{completion_dir}"
    FileUtils.cp(File.expand_path('../../completion/poet.bash', __FILE__), completion_dir)
    say %Q(To use the completion, execute this command:\n
    echo 'source #{File.join(completion_dir, 'poet.bash')}' >> ~/.bashrc)
  end

  desc "", "Concatenate all host stanzas under ~/.ssh/config.d/ into a single ~/.ssh/config"
  def create
    runtime_opts = { dir: options[:dir], force_include: options[:with], output: options[:output] }
    Poet::Runtime.new(runtime_opts).create do |file|
      $stdout.puts "Using #{file}" if options.verbose?
    end

  rescue Poet::NotBootstrapped
    $stderr.puts "#{options[:dir]} does not exist or is not a directory"
    Process.exit!(1)
  rescue Poet::HandCraftedConfigFound
    $stderr.puts "Found hand-crafted ssh_config under #{options[:output]}. Please move it out of the way or specify a different output file with the -o option."
    Process.exit!(2)
  end

  desc "edit FILE", "Open FILE under ~/.ssh/config.d/ in your favorite $EDITOR"
  def edit(file)
    Poet::Runtime.new(dir: options[:dir], output: options[:output]).edit(file)
  rescue Poet::EmptyEditorVar
    $stderr.puts "$EDITOR is empty. Could not determine your favorite editor."
    Process.exit!(4)
  end

  desc "ls", "List all configuration files"
  option :tree, aliases: '-t', type: :boolean, desc: 'Print tree of config dir'
  def ls
    Poet::Runtime.new(dir: options[:dir]).ls(show_tree: options.tree?)
  end
end